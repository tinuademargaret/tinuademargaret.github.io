<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> An overview of language model (Part 2) | Tinuade Margaret </title> <meta name="author" content="Tinuade Margaret"> <meta name="description" content="Where we are now"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://tinuademargaret.github.io/blog/2022/language-model-overview-2/"> <script src="/assets/js/theme.js?a5ca4084d3b81624bcfa01156dae2b8e"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Tinuade</span> Margaret </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">An overview of language model (Part 2)</h1> <p class="post-meta"> November 14, 2022 </p> <p class="post-tags"> <a href="/blog/2022"> <i class="fa-solid fa-calendar fa-sm"></i> 2022 </a>   ·   <a href="/blog/tag/ai"> <i class="fa-solid fa-hashtag fa-sm"></i> AI</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <p>In the previous post we looked at how languge modelling was done with n-gram models and some key components of neural language models namely the embedding layer and the softmax layer.</p> <p>While the Embedding layer and the softmax layer are common to LMs in general, the network layer varies and is a distinguishing factor in the capabilities of LMs. In this post, we’ll look at two major architectures namely Recurrent Neural Networks (RNN) and Transformer Networks.</p> <h2 id="reccurent-neural-networks">Reccurent Neural Networks</h2> <p>The major difference between a vanilla Neural Network commonly referred to as a Feed Forward Neural Network (FFNN) and an RNN, is the incorporation of memory (the output of hidden layer neurons) as an additional input to the network during the next step training on sequential data. The layers in an RNN contain RNN cells as opposed to neurons seen in FFNNs. The output of an RNN cell at time <em>t</em> depends on the current inputs, their weights, and also the output of the hidden layer in the previous time step.</p> <p>Because of the additional memory component, the error of the output of the model is usually backpropagated through previous timesteps and if backpropagation is done for more than approximately ten timesteps the gradient can become either very small leading to a vanishing gradient problem or grow uncontrollably leading to an exploding gradient problem. The vanishing gradient problem especially hinders the capability of the model to capture information several time steps back.</p> <p>Long Short-Term Memory Networks (LSTMs) and Gated Recurrent Networks (GRNs) are variants of RNNs proposed to solve the vanishing gradient problem. Christopher Olah gives a good breakdown on RNNs <a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/" rel="external nofollow noopener" target="_blank">here</a>.</p> <h2 id="sequence-to-sequence-models">Sequence-to-Sequence models</h2> <p>The encoder-decoder sequence-to-sequence model was originally proposed to overcome the limitations of performing sequence-to-sequence mapping with neural networks especially in machine translation tasks.</p> <p>For an RNN to process sequential data the dimensions of the input and output have to be known and fixed, but in many cases, problems are best expressed as sequences whose lengths are not previously known, or whose input sequence length varies from the output sequence length such as in machine translation.</p> <p>In a vanilla sequence-to-sequence model, the encoder and decoder is usually any of the RNNs mentioned above. The encoder takes an entire input sentence and maps it to a fixed-sized vector. This vector is then fed into the decoder which then maps the vector to a target sequence.</p> <p>Let’s talk a bit about the attention mechanism.</p> <h3 id="attention-mechanism">Attention mechanism</h3> <p>Attention mechanism in machine learning originated from the observation that humans process sensory information in a sequential manner, paying special attention to a part of the whole information at a time. Researchers have used the Attention mechanism to replicate this behaviour in neural networks enabling them to focus on a subset of input information at a time. For example, in image captioning, a computer vision network can focus on different parts of the image at a time to produce a more accurate caption.</p> <p>Attention between two sequences was initially introduced in a neural machine translation task. Before the use of attention, when performing machine translation tasks using sequence-to-sequence models, as we have described above, the entire input sequence is passed as a vector from the encoder to the decoder. Still, with attention, the encoder passes information about each word it processes to the decoder, but the decoder can focus on words as they become important.</p> <p>To induce attention, the decoder scores the set of vectors (each associated with a word in the input sequence) from the encoder at each time step. It applies a softmax function to create an attention distribution. Each vector is then multiplied by its softmax score, drowning out vectors with lower scores and amplifying vectors with higher scores. There is a nice visualization of sequence to sequence models by Jay Alammar <a href="https://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/" rel="external nofollow noopener" target="_blank">here</a></p> <p>The attention mechanism introduced in vanilla sequence-to-sequence models made it compelling, but there was still an issue of computational efficiency since computation was done sequentially using recurrent models. This led to a proposal for the Transformer to reduce the sequential computation in sequential modelling tasks.</p> <h2 id="transformers">Transformers</h2> <p>The original proposed transformer is composed of an encoder-decoder network. It removes which the recurrent connections seen in sequence to sequence models, and uses the attention mechanism to model information across long sequences. The function of the encoder and decoder in a transformer network remains just the same as in a vanilla sequence-to-sequence model but the transformer network uses not just an encoder and a decoder but a stack of encoders and decoders. Each encoder and decoder can be seen as a layer of the transformer network. Each layer of the decoder is made up of two sub-layers, a multi-head attention layer and a feed-forward layer which is essentially a feed-forward neural network. A Layer normalisation is also included around the sub-layers which helps to improve the training speed of the model. In addition to the sub-layers seen in the encoder, the decoder has a third sub-layer for performing multi-head attention over the output of the encoder stack.</p> <p>Instead of relying on the output of the previous state to encode information about the last step time in the current time step, attention is used in transformers to encode information about relevant words into a word currently being processed. The process to achieve this is similar to the one described above between an encoder and a decoder in a vanilla sequence-to-sequence model with attention. In this case, we score each word in an input sentence against a word currently being processed, and this score determines how much focus should be placed on the other words in the input sentence as one is currently encoded. A softmax function is then applied to the scores. A value vector for each word is then multiplied by the softmax score for each word, again drowning out vectors with lower scores and amplifying vectors with higher scores. The vectors are then summed up to produce the output of the attention layer in an encoder and fed into the feed-forward layer. This calculation is done multiple times to create \emph{multi-headed} attention and improves the performance of the attention layer.</p> <h3 id="positional-embeddings">Positional Embeddings</h3> <p>Transformers need a way to represent the position of words in a sequence of input since they do not have recurrent connections. To address this, the proposed model adds a vector to each input word embedding called a position embedding that helps it know the position of each word and the distance from each word. The positional embedding follows a specific pattern and can either be learned or determined by a pre-defined function. The sinusoid function was used in the original implementation.</p> <p>The Transformers, since its inception, has been highly adopted as a model architecture for LMs. Some popular based Transformer based language models include BERT, RETRO, GPT-2 and its successors.</p> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Tinuade Margaret. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?5d75c11f89cd96294bf5e6dd1ee1bb30"></script> <script defer src="/assets/js/common.js?fcfacfb8c6281f5e68d5a7d348186eb1"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>